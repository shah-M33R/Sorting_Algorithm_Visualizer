<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Project Report - Sorting Visualizer</title>
    <style>
      body {
        font-family: "Times New Roman", serif;
        line-height: 1.6;
        max-width: 800px;
        margin: 0 auto;
        padding: 40px;
        color: #000;
      }
      ul {
        list-style: none;
        padding-left: 0;
        margin-left: 0;
        margin-top: 0px;
      }
      h1,
      h2,
      h3 {
        color: #2c3e50;
      }
      h1 {
        text-align: center;
        border-bottom: 2px solid #2c3e50;
        padding-bottom: 10px;
        margin-bottom: 30px;
      }
      .header-info {
        text-align: center;
        margin-bottom: 40px;
        font-size: 1.2rem;
        border-bottom: 2px solid #2c3e50;
        padding-bottom: 10px;
      }
      .section {
        margin-bottom: 30px;
      }
      .diagram {
        background-color: #f8f9fa;
        padding: 15px;
        border: 1px solid #ddd;
        font-family: monospace;
        white-space: pre;
        overflow-x: auto;
        margin: 15px 0;
        border-radius: 5px;
        font-size: 0.9em;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin: 20px 0;
        font-size: 0.95em;
      }
      th,
      td {
        border: 1px solid #ddd;
        padding: 10px;
        text-align: left;
      }
      th {
        background-color: #f2f2f2;
        font-weight: bold;
      }
      .feature-highlight {
        background-color: #e8f4fd;
        padding: 10px;
        border-left: 4px solid #3498db;
        margin: 10px 0;
      }
      @media print {
        .page-break {
          page-break-after: always;
        }
      }
    </style>
  </head>
  <body>
    <h1>Interactive Sorting Algorithm Visualizer</h1>

    <div class="header-info">
        <p><strong> Program:</strong> BS Software Engineering</p>
        <p><strong> Semester:</strong>:</strong> 3rd - Regular</p>
      <p><strong>Course:</strong> Data Structures & Algorithms</p>
        <strong>Team Members:</strong> <ul>
            <li>17 - Sawera Mumtaz (Group Leader)</li>
            <li>02 - Hanzla Rani</li>
            <li>03 - Shahmeer Hassan</li>
            <li>42 - Alishba</li>
            <li>50 - Huzaifah Iftikhar</li>
        </ul>
    </div>

    <div class="section">
      <h2>1. Project Overview</h2>
      <h3>Problem Statement</h3>
      <p>
        Sorting algorithms are fundamental to computer science, yet
        understanding their internal mechanics—specifically the difference
        between comparison-based strategies and non-comparison based
        efficiency—is difficult to grasp through static code. Students often
        struggle to visualize how memory is manipulated in algorithms like Merge
        Sort or how time complexity scales with input size.
      </p>

      <h3>Purpose</h3>
      <p>
        The <strong>Interactive Sorting Algorithm Visualizer</strong> is a
        robust educational tool designed to visualize the step-by-step execution
        of 9 distinct sorting algorithms. By utilizing a high-performance C++
        backend for execution and a React frontend for rendering, the system
        provides accurate, real-time performance metrics and visualizes datasets
        ranging from small arrays to massive, scrollable datasets.
      </p>
    </div>

    <div class="section">
      <h2>2. System Architecture</h2>
      <p>
        The system utilizes a <strong>Decoupled Architecture</strong> designed
        for high data throughput and memory efficiency.
      </p>

      <h3>2.1 Core Components</h3>
      <ul>
        <li>
          <strong>Backend (C++17):</strong> The computational engine. It
          generates datasets, executes algorithms, and serializes the execution
          history. It features a custom
          <strong>Delta Compression</strong> engine to minimize memory usage
          during logging.
        </li>
        <li>
          <strong>Frontend (React/TypeScript):</strong> The visualization layer.
          It parses the compressed logs and uses a
          <strong>Scalable Canvas Renderer</strong> to draw frame-by-frame
          animations.
        </li>
        <li>
          <strong>Data Interchange (JSON):</strong> Acts as the interface
          between the producer (C++) and consumer (Web).
        </li>
      </ul>

      <h3>2.2 Data Flow Pipeline</h3>
      <div class="diagram">
        1. Generation: User selects Algorithm & Size (CLI) │ 2. Execution: C++
        Engine runs sort │ 3. Optimization: StepRecorder calculates 'Diffs'
        (Only changed indices recorded, not full array) │ 4. Serialization:
        Compressed JSON log generated │ 5. Reconstruction: Frontend loads JSON │
        6. Rendering: Canvas applies Diffs to local state & renders
      </div>
    </div>

    <div class="page-break"></div>

    <div class="section">
      <h2>3. Algorithmic Implementation</h2>
      <p>
        The project implements a comprehensive suite of algorithms, categorized
        by their sorting strategy. All implementations are instrumented to
        record Comparisons, Swaps, and Time Complexity.
      </p>

      <h3>Comparison-Based Algorithms</h3>
      <table>
        <thead>
          <tr>
            <th>Algorithm</th>
            <th>Complexity</th>
            <th>Visualization Mechanic</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Bubble Sort</td>
            <td>O(n²)</td>
            <td>
              Standard adjacent swapping. Optimized with an early-exit flag.
            </td>
          </tr>
          <tr>
            <td>Selection Sort</td>
            <td>O(n²)</td>
            <td>
              Highlights the linear scan for the minimum element (Amber) before
              swapping.
            </td>
          </tr>
          <tr>
            <td>Insertion Sort</td>
            <td>O(n²)</td>
            <td>
              Visualizes the "shift and overwrite" mechanism for the sorted
              subarray.
            </td>
          </tr>
          <tr>
            <td>Shell Sort</td>
            <td>O(n log n)</td>
            <td>
              Visualizes gap-based insertion, showing how elements move long
              distances initially.
            </td>
          </tr>
          <tr>
            <td>Merge Sort</td>
            <td>O(n log n)</td>
            <td>
              Recursive Divide & Conquer. Visualizes the merging of auxiliary
              arrays.
            </td>
          </tr>
          <tr>
            <td>Quick Sort</td>
            <td>O(n log n)</td>
            <td>
              Lomuto Partition scheme. Explicitly highlights the
              <strong>Pivot</strong> (Violet) and partition boundaries.
            </td>
          </tr>
          <tr>
            <td>Heap Sort</td>
            <td>O(n log n)</td>
            <td>
              Visualizes the Max-Heap structure and the "sift-down" process.
            </td>
          </tr>
        </tbody>
      </table>

      <h3>Non-Comparison Algorithms (New)</h3>
      <table>
        <thead>
          <tr>
            <th>Algorithm</th>
            <th>Complexity</th>
            <th>Visualization Mechanic</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Radix Sort (LSD)</td>
            <td>O(nk)</td>
            <td>
              Visualizes distribution into buckets based on digit position
              (units, tens, etc.).
            </td>
          </tr>
          <tr>
            <td>Bucket Sort</td>
            <td>O(n + k)</td>
            <td>
              Visualizes scattering elements into ranges and gathering them
              back.
            </td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="section">
      <h2>4. Technical Optimization & Performance</h2>

      <div class="feature-highlight">
        <strong>Feature 1: Delta Compression Protocol</strong><br />
        To support large datasets (N > 1,000), the backend does not save the
        full array for every frame. Instead, the <code>StepRecorder</code> logs
        only the <em>indices that changed</em> (e.g.,
        <code>"op": "swap", "indices": [4, 5]</code>). This reduces the output
        file size by approximately <strong>90%</strong> compared to full-state
        logging, allowing for massive logs to be generated and loaded instantly.
      </div>

      <div class="feature-highlight">
        <strong>Feature 2: Scalable Canvas Rendering</strong><br />
        The frontend implementation handles high-density arrays.
        <ul>
          <li>
            <strong>Dynamic Width Calculation:</strong> Bar width is calculated
            as floating-point to ensure sub-pixel rendering accuracy on high-DPI
            displays.
          </li>
          <li>
            <strong>Scroll Support:</strong> For extremely large datasets (N >
            2,000), the canvas enables a horizontal scroll mode, preventing bars
            from becoming too thin to see.
          </li>
        </ul>
      </div>
    </div>

    <div class="section">
      <h2>5. Conclusion</h2>
      <p>
        This project fulfills the requirements of an advanced educational tool.
        By implementing both standard comparison sorts and complex
        non-comparison sorts, and by optimizing the data pipeline with delta
        compression, the system demonstrates high technical proficiency. It
        allows users to gain a deep intuition for algorithmic efficiency through
        interactive exploration.
      </p>
    </div>
  </body>
</html>
