<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Technical Documentation - Sorting Visualizer</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 850px;
            margin: 0 auto;
            padding: 40px;
            background-color: #fff;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 15px;
            text-align: center;
            margin-bottom: 40px;
        }
        h2 {
            color: #2980b9;
            margin-top: 40px;
            border-left: 5px solid #2980b9;
            padding-left: 15px;
        }
        h3 {
            color: #34495e;
            margin-top: 25px;
            font-weight: 600;
        }
        p {
            margin-bottom: 15px;
            text-align: justify;
        }
        ul {
            margin-bottom: 20px;
        }
        li {
            margin-bottom: 8px;
        }
        code {
            background-color: #f7f9fa;
            border: 1px solid #e1e4e8;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            color: #e74c3c;
            font-size: 0.9em;
        }
        pre {
            background-color: #2d3436;
            color: #f1f2f6;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
            margin: 20px 0;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .file-tree {
    font-family: 'Consolas', monospace;
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    padding: 20px;
    margin: auto;
    border-radius: 5px;
    line-height: 1.4;
    white-space: pre-wrap;
    overflow-wrap: anywhere;
    width: 93%;
}

        .note {
            background-color: #e8f4fd;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 20px 0;
            font-style: italic;
        }
        /* Print optimizations */
        @media print {
            body { padding: 0; max-width: 100%; }
            .page-break { page-break-after: always; }
            h2 { margin-top: 20px; }
            pre { white-space: pre-wrap; word-wrap: break-word; }
        }
    </style>
</head>
<body>

    <h1>Technical Documentation</h1>
    
    <div style="text-align: center; font-style: italic; margin-bottom: 50px;">
        <p><strong>Project:</strong> Interactive Sorting Algorithm Visualizer</p>
        <p><strong>Architecture:</strong> Hybrid C++17 Backend / React TypeScript Frontend</p>
    </div>

    <h2>1. Project File Structure</h2>
    <p>The project is organized into two distinct workspaces: <code>cpp-core</code> for logic execution and <code>frontend</code> for visualization. This separation of concerns ensures modularity and ease of testing.</p>

    <div class="file-tree">
project-root/
├── <strong>cpp-core/</strong> (The Logic Engine)
│   ├── <strong>algorithms/</strong>: Implementation of specific sorting logic.
│   │   ├── bubble.cpp, quick.cpp, merge.cpp...
│   │   └── SortEngine.cpp (Factory pattern for algorithm dispatch)
│   ├── <strong>step_recorder/</strong>:
│   │   └── StepRecorder.cpp (Handles state capture and JSON serialization)
│   ├── <strong>include/</strong>: Headers defining Step structs and interfaces.
│   ├── <strong>main.cpp</strong>: CLI entry point; handles arguments and file I/O.
│   └── <strong>CMakeLists.txt</strong>: Build configuration.
│
├── <strong>frontend/</strong> (The Visualization UI)
│   ├── <strong>src/</strong>
│   │   ├── <strong>components/</strong>:
│   │   │   ├── VisualizerCanvas.tsx (HTML5 Canvas rendering)
│   │   │   └── ControlPanel.tsx (Playback controls)
│   │   ├── <strong>utils/</strong>:
│   │   │   └── StepParser.ts (JSON validation and parsing)
│   │   ├── <strong>types.ts</strong>: TypeScript interfaces for the Data Layer.
│   │   └── <strong>App.tsx</strong>: Main controller and state manager.
│   └── <strong>public/</strong>: Stores generated JSON logs.
│
└── <strong>deliverables/</strong>: Documentation (Project Report, User Manual, Technical Docs).</div>

    <div class="page-break"></div>

    <h2>2. Frontend Architecture (The View)</h2>
    <p>The frontend acts as a "dumb player." It contains no sorting logic of its own. Its primary responsibility is to faithfully render the data provided by the backend.</p>

    <h3>2.1 Component Hierarchy</h3>
    <ul>
        <li><strong><code>App.tsx</code> (Controller):</strong> Manages the global state, including:
            <ul>
                <li><code>log</code>: The loaded JSON object containing the full sorting history.</li>
                <li><code>currentFrameIndex</code>: An integer pointing to the current step in time.</li>
                <li><code>isPlaying</code> / <code>speed</code>: Playback state variables.</li>
            </ul>
        </li>
        <li><strong><code>VisualizerCanvas.tsx</code> (Renderer):</strong> 
            <p>Instead of using HTML DOM elements (like <code>&lt;div&gt;</code>) which cause performance bottlenecks with large arrays, this component utilizes the <strong>HTML5 Canvas API</strong>. It redraws the entire array array frame-by-frame using immediate mode rendering, ensuring 60 FPS performance.</p>
        </li>
        <li><strong><code>ControlPanel.tsx</code> (Input):</strong> Handles user interactions (Play, Pause, Reset, Seek) and calls state updater functions in <code>App.tsx</code>.</li>
    </ul>

    <h3>2.2 The Animation Loop</h3>
    <p>To ensure smooth visualization, we utilize <code>requestAnimationFrame</code> instead of standard JavaScript intervals. This synchronizes rendering with the browser's refresh rate.</p>

    <h2>3. Backend Architecture (The Engine)</h2>
    <p>The backend is built with <strong>C++17</strong> for performance. It follows an "Offline Rendering" pipeline.</p>

    <h3>3.1 C++ Execution Engine</h3>
    <p>The entry point is <code>main.cpp</code>, which parses command-line arguments (e.g., <code>--algorithm quick --size 100</code>). It initializes the <code>SortEngine</code>, which uses a Factory Pattern to select the correct algorithm (e.g., calling <code>QuickSort::sort</code>).</p>

    <h3>3.2 Snapshot Generation (The "Observer")</h3>
    <p>To visualize an algorithm, we must observe its internal state changes. We achieve this using a <strong>StepRecorder</strong> class. Algorithms are "instrumented" to report operations.</p>
    
    <p><strong>Code Example (Instrumentation in C++):</strong></p>
    <pre>
// Inside a sorting loop
if (arr[j] > arr[j+1]) {
    // 1. Perform logic
    std::swap(arr[j], arr[j+1]); 
    
    // 2. Record Snapshot (Observer)
    // We notify the recorder that a 'swap' happened at these indices
    recorder.recordSnapshot(arr, {j, j+1}, ActionType::SWAP);
}</pre>

    <p>This effectively takes a "photo" of the array memory at that exact millisecond, along with metadata about which indices were touched.</p>

    <div class="page-break"></div>

    <h3>3.3 JSON Generator (Serialization)</h3>
    <p>Once the sorting algorithm finishes, the <code>StepRecorder</code> holds a vector of all snapshots. The <code>flushToFile</code> method serializes this history into a strictly formatted JSON file using the <code>nlohmann/json</code> library.</p>

    <p><strong>Why JSON?</strong> It decouples the backend from the frontend. We can swap the C++ backend for a Python one, or the React frontend for a Desktop app, without breaking the system.</p>

    <h2>4. The Data Layer (JSON Loader)</h2>
    <p>The JSON file serves as the contract between the two systems. The frontend loader (<code>StepParser.ts</code>) validates this structure before playback.</p>

    <h3>4.1 JSON Schema</h3>
    <pre>
{
  "metadata": {
    "algorithm": "Quick Sort",
    "input_size": 50,
    "total_comparisons": 120,
    "total_swaps": 45
  },
  "frames": [
    {
      "array": [10, 5, 2, ...],        // The state of data
      "highlights": {                  // Visual cues
         "compare": [0, 1],            // Draw indices 0 & 1 as Amber
         "swap": [], 
         "pivot": 4                    // Draw index 4 as Violet
      },
      "operation": "compare"           // Description for UI text
    },
    ...
  ]
}</pre>

    <h2>5. Implementation of Algorithms</h2>
    <p>The backend implements 7 algorithms, categorized by their visualization characteristics:</p>
    <ul>
        <li><strong>Bubble & Insertion:</strong> O(n²). Visualized as "waves" of sorted data moving across the canvas.</li>
        <li><strong>Selection Sort:</strong> O(n²). Highlights the linear scan (Amber) to find the minimum element before a single Swap (Red).</li>
        <li><strong>Quick Sort:</strong> O(n log n). Uses the <strong>Lomuto Partition Scheme</strong>. The visualizer explicitly tracks the <strong>Pivot</strong> index to show how the array is divided.</li>
        <li><strong>Merge Sort:</strong> O(n log n). Visualizes the recursive divide-and-conquer strategy by highlighting ranges being merged.</li>
        <li><strong>Heap Sort:</strong> O(n log n). Visualizes the "Heapify" process (sifting elements down) followed by the extraction of the max element.</li>
    </ul>

    <div class="note">
        <strong>Requirement Check:</strong> This architecture satisfies all project constraints: Modularity (Backend/Frontend split), Correctness (C++ STL logic), and Visualization Accuracy (Frame-by-frame recording).
    </div>

</body>
</html>